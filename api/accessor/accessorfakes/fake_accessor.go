// Code generated by counterfeiter. DO NOT EDIT.
package accessorfakes

import (
	"sync"

	"github.com/concourse/atc/api/accessor"
	"github.com/concourse/atc/db"
)

type FakeAccessor struct {
	AdminStub        func(accessor.Access) (db.Admin, error)
	adminMutex       sync.RWMutex
	adminArgsForCall []struct {
		arg1 accessor.Access
	}
	adminReturns struct {
		result1 db.Admin
		result2 error
	}
	adminReturnsOnCall map[int]struct {
		result1 db.Admin
		result2 error
	}
	PipelinesStub        func(accessor.Access) ([]db.Pipeline, error)
	pipelinesMutex       sync.RWMutex
	pipelinesArgsForCall []struct {
		arg1 accessor.Access
	}
	pipelinesReturns struct {
		result1 []db.Pipeline
		result2 error
	}
	pipelinesReturnsOnCall map[int]struct {
		result1 []db.Pipeline
		result2 error
	}
	TeamsStub        func(accessor.Access) ([]db.Team, error)
	teamsMutex       sync.RWMutex
	teamsArgsForCall []struct {
		arg1 accessor.Access
	}
	teamsReturns struct {
		result1 []db.Team
		result2 error
	}
	teamsReturnsOnCall map[int]struct {
		result1 []db.Team
		result2 error
	}
	TeamStub        func(accessor.Access, string) (db.Team, error)
	teamMutex       sync.RWMutex
	teamArgsForCall []struct {
		arg1 accessor.Access
		arg2 string
	}
	teamReturns struct {
		result1 db.Team
		result2 error
	}
	teamReturnsOnCall map[int]struct {
		result1 db.Team
		result2 error
	}
	TeamPipelinesStub        func(accessor.Access, string) ([]db.Pipeline, error)
	teamPipelinesMutex       sync.RWMutex
	teamPipelinesArgsForCall []struct {
		arg1 accessor.Access
		arg2 string
	}
	teamPipelinesReturns struct {
		result1 []db.Pipeline
		result2 error
	}
	teamPipelinesReturnsOnCall map[int]struct {
		result1 []db.Pipeline
		result2 error
	}
	TeamPipelineStub        func(accessor.Access, string, string) (db.Pipeline, error)
	teamPipelineMutex       sync.RWMutex
	teamPipelineArgsForCall []struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
	}
	teamPipelineReturns struct {
		result1 db.Pipeline
		result2 error
	}
	teamPipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 error
	}
	TeamPipelineJobsStub        func(accessor.Access, string, string) ([]db.Job, error)
	teamPipelineJobsMutex       sync.RWMutex
	teamPipelineJobsArgsForCall []struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
	}
	teamPipelineJobsReturns struct {
		result1 []db.Job
		result2 error
	}
	teamPipelineJobsReturnsOnCall map[int]struct {
		result1 []db.Job
		result2 error
	}
	TeamPipelineJobStub        func(accessor.Access, string, string, string) (db.Job, error)
	teamPipelineJobMutex       sync.RWMutex
	teamPipelineJobArgsForCall []struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
		arg4 string
	}
	teamPipelineJobReturns struct {
		result1 db.Job
		result2 error
	}
	teamPipelineJobReturnsOnCall map[int]struct {
		result1 db.Job
		result2 error
	}
	TeamPipelineJobBuildStub        func(accessor.Access, string, string, string, string) (db.Build, error)
	teamPipelineJobBuildMutex       sync.RWMutex
	teamPipelineJobBuildArgsForCall []struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	teamPipelineJobBuildReturns struct {
		result1 db.Build
		result2 error
	}
	teamPipelineJobBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	CreateTeampipelinJobBuildsStub        func(string, string, string, string)
	createTeampipelinJobBuildsMutex       sync.RWMutex
	createTeampipelinJobBuildsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	TeamPipelineResourcesStub        func(accessor.Access, string, string) ([]db.Resource, error)
	teamPipelineResourcesMutex       sync.RWMutex
	teamPipelineResourcesArgsForCall []struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
	}
	teamPipelineResourcesReturns struct {
		result1 []db.Resource
		result2 error
	}
	teamPipelineResourcesReturnsOnCall map[int]struct {
		result1 []db.Resource
		result2 error
	}
	TeamPipelineResourceStub        func(accessor.Access, string, string, string) (db.Resource, error)
	teamPipelineResourceMutex       sync.RWMutex
	teamPipelineResourceArgsForCall []struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
		arg4 string
	}
	teamPipelineResourceReturns struct {
		result1 db.Resource
		result2 error
	}
	teamPipelineResourceReturnsOnCall map[int]struct {
		result1 db.Resource
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAccessor) Admin(arg1 accessor.Access) (db.Admin, error) {
	fake.adminMutex.Lock()
	ret, specificReturn := fake.adminReturnsOnCall[len(fake.adminArgsForCall)]
	fake.adminArgsForCall = append(fake.adminArgsForCall, struct {
		arg1 accessor.Access
	}{arg1})
	fake.recordInvocation("Admin", []interface{}{arg1})
	fake.adminMutex.Unlock()
	if fake.AdminStub != nil {
		return fake.AdminStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.adminReturns.result1, fake.adminReturns.result2
}

func (fake *FakeAccessor) AdminCallCount() int {
	fake.adminMutex.RLock()
	defer fake.adminMutex.RUnlock()
	return len(fake.adminArgsForCall)
}

func (fake *FakeAccessor) AdminArgsForCall(i int) accessor.Access {
	fake.adminMutex.RLock()
	defer fake.adminMutex.RUnlock()
	return fake.adminArgsForCall[i].arg1
}

func (fake *FakeAccessor) AdminReturns(result1 db.Admin, result2 error) {
	fake.AdminStub = nil
	fake.adminReturns = struct {
		result1 db.Admin
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) AdminReturnsOnCall(i int, result1 db.Admin, result2 error) {
	fake.AdminStub = nil
	if fake.adminReturnsOnCall == nil {
		fake.adminReturnsOnCall = make(map[int]struct {
			result1 db.Admin
			result2 error
		})
	}
	fake.adminReturnsOnCall[i] = struct {
		result1 db.Admin
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) Pipelines(arg1 accessor.Access) ([]db.Pipeline, error) {
	fake.pipelinesMutex.Lock()
	ret, specificReturn := fake.pipelinesReturnsOnCall[len(fake.pipelinesArgsForCall)]
	fake.pipelinesArgsForCall = append(fake.pipelinesArgsForCall, struct {
		arg1 accessor.Access
	}{arg1})
	fake.recordInvocation("Pipelines", []interface{}{arg1})
	fake.pipelinesMutex.Unlock()
	if fake.PipelinesStub != nil {
		return fake.PipelinesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pipelinesReturns.result1, fake.pipelinesReturns.result2
}

func (fake *FakeAccessor) PipelinesCallCount() int {
	fake.pipelinesMutex.RLock()
	defer fake.pipelinesMutex.RUnlock()
	return len(fake.pipelinesArgsForCall)
}

func (fake *FakeAccessor) PipelinesArgsForCall(i int) accessor.Access {
	fake.pipelinesMutex.RLock()
	defer fake.pipelinesMutex.RUnlock()
	return fake.pipelinesArgsForCall[i].arg1
}

func (fake *FakeAccessor) PipelinesReturns(result1 []db.Pipeline, result2 error) {
	fake.PipelinesStub = nil
	fake.pipelinesReturns = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) PipelinesReturnsOnCall(i int, result1 []db.Pipeline, result2 error) {
	fake.PipelinesStub = nil
	if fake.pipelinesReturnsOnCall == nil {
		fake.pipelinesReturnsOnCall = make(map[int]struct {
			result1 []db.Pipeline
			result2 error
		})
	}
	fake.pipelinesReturnsOnCall[i] = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) Teams(arg1 accessor.Access) ([]db.Team, error) {
	fake.teamsMutex.Lock()
	ret, specificReturn := fake.teamsReturnsOnCall[len(fake.teamsArgsForCall)]
	fake.teamsArgsForCall = append(fake.teamsArgsForCall, struct {
		arg1 accessor.Access
	}{arg1})
	fake.recordInvocation("Teams", []interface{}{arg1})
	fake.teamsMutex.Unlock()
	if fake.TeamsStub != nil {
		return fake.TeamsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamsReturns.result1, fake.teamsReturns.result2
}

func (fake *FakeAccessor) TeamsCallCount() int {
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	return len(fake.teamsArgsForCall)
}

func (fake *FakeAccessor) TeamsArgsForCall(i int) accessor.Access {
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	return fake.teamsArgsForCall[i].arg1
}

func (fake *FakeAccessor) TeamsReturns(result1 []db.Team, result2 error) {
	fake.TeamsStub = nil
	fake.teamsReturns = struct {
		result1 []db.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamsReturnsOnCall(i int, result1 []db.Team, result2 error) {
	fake.TeamsStub = nil
	if fake.teamsReturnsOnCall == nil {
		fake.teamsReturnsOnCall = make(map[int]struct {
			result1 []db.Team
			result2 error
		})
	}
	fake.teamsReturnsOnCall[i] = struct {
		result1 []db.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) Team(arg1 accessor.Access, arg2 string) (db.Team, error) {
	fake.teamMutex.Lock()
	ret, specificReturn := fake.teamReturnsOnCall[len(fake.teamArgsForCall)]
	fake.teamArgsForCall = append(fake.teamArgsForCall, struct {
		arg1 accessor.Access
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Team", []interface{}{arg1, arg2})
	fake.teamMutex.Unlock()
	if fake.TeamStub != nil {
		return fake.TeamStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamReturns.result1, fake.teamReturns.result2
}

func (fake *FakeAccessor) TeamCallCount() int {
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	return len(fake.teamArgsForCall)
}

func (fake *FakeAccessor) TeamArgsForCall(i int) (accessor.Access, string) {
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	return fake.teamArgsForCall[i].arg1, fake.teamArgsForCall[i].arg2
}

func (fake *FakeAccessor) TeamReturns(result1 db.Team, result2 error) {
	fake.TeamStub = nil
	fake.teamReturns = struct {
		result1 db.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamReturnsOnCall(i int, result1 db.Team, result2 error) {
	fake.TeamStub = nil
	if fake.teamReturnsOnCall == nil {
		fake.teamReturnsOnCall = make(map[int]struct {
			result1 db.Team
			result2 error
		})
	}
	fake.teamReturnsOnCall[i] = struct {
		result1 db.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelines(arg1 accessor.Access, arg2 string) ([]db.Pipeline, error) {
	fake.teamPipelinesMutex.Lock()
	ret, specificReturn := fake.teamPipelinesReturnsOnCall[len(fake.teamPipelinesArgsForCall)]
	fake.teamPipelinesArgsForCall = append(fake.teamPipelinesArgsForCall, struct {
		arg1 accessor.Access
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("TeamPipelines", []interface{}{arg1, arg2})
	fake.teamPipelinesMutex.Unlock()
	if fake.TeamPipelinesStub != nil {
		return fake.TeamPipelinesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamPipelinesReturns.result1, fake.teamPipelinesReturns.result2
}

func (fake *FakeAccessor) TeamPipelinesCallCount() int {
	fake.teamPipelinesMutex.RLock()
	defer fake.teamPipelinesMutex.RUnlock()
	return len(fake.teamPipelinesArgsForCall)
}

func (fake *FakeAccessor) TeamPipelinesArgsForCall(i int) (accessor.Access, string) {
	fake.teamPipelinesMutex.RLock()
	defer fake.teamPipelinesMutex.RUnlock()
	return fake.teamPipelinesArgsForCall[i].arg1, fake.teamPipelinesArgsForCall[i].arg2
}

func (fake *FakeAccessor) TeamPipelinesReturns(result1 []db.Pipeline, result2 error) {
	fake.TeamPipelinesStub = nil
	fake.teamPipelinesReturns = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelinesReturnsOnCall(i int, result1 []db.Pipeline, result2 error) {
	fake.TeamPipelinesStub = nil
	if fake.teamPipelinesReturnsOnCall == nil {
		fake.teamPipelinesReturnsOnCall = make(map[int]struct {
			result1 []db.Pipeline
			result2 error
		})
	}
	fake.teamPipelinesReturnsOnCall[i] = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipeline(arg1 accessor.Access, arg2 string, arg3 string) (db.Pipeline, error) {
	fake.teamPipelineMutex.Lock()
	ret, specificReturn := fake.teamPipelineReturnsOnCall[len(fake.teamPipelineArgsForCall)]
	fake.teamPipelineArgsForCall = append(fake.teamPipelineArgsForCall, struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("TeamPipeline", []interface{}{arg1, arg2, arg3})
	fake.teamPipelineMutex.Unlock()
	if fake.TeamPipelineStub != nil {
		return fake.TeamPipelineStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamPipelineReturns.result1, fake.teamPipelineReturns.result2
}

func (fake *FakeAccessor) TeamPipelineCallCount() int {
	fake.teamPipelineMutex.RLock()
	defer fake.teamPipelineMutex.RUnlock()
	return len(fake.teamPipelineArgsForCall)
}

func (fake *FakeAccessor) TeamPipelineArgsForCall(i int) (accessor.Access, string, string) {
	fake.teamPipelineMutex.RLock()
	defer fake.teamPipelineMutex.RUnlock()
	return fake.teamPipelineArgsForCall[i].arg1, fake.teamPipelineArgsForCall[i].arg2, fake.teamPipelineArgsForCall[i].arg3
}

func (fake *FakeAccessor) TeamPipelineReturns(result1 db.Pipeline, result2 error) {
	fake.TeamPipelineStub = nil
	fake.teamPipelineReturns = struct {
		result1 db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineReturnsOnCall(i int, result1 db.Pipeline, result2 error) {
	fake.TeamPipelineStub = nil
	if fake.teamPipelineReturnsOnCall == nil {
		fake.teamPipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 error
		})
	}
	fake.teamPipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineJobs(arg1 accessor.Access, arg2 string, arg3 string) ([]db.Job, error) {
	fake.teamPipelineJobsMutex.Lock()
	ret, specificReturn := fake.teamPipelineJobsReturnsOnCall[len(fake.teamPipelineJobsArgsForCall)]
	fake.teamPipelineJobsArgsForCall = append(fake.teamPipelineJobsArgsForCall, struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("TeamPipelineJobs", []interface{}{arg1, arg2, arg3})
	fake.teamPipelineJobsMutex.Unlock()
	if fake.TeamPipelineJobsStub != nil {
		return fake.TeamPipelineJobsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamPipelineJobsReturns.result1, fake.teamPipelineJobsReturns.result2
}

func (fake *FakeAccessor) TeamPipelineJobsCallCount() int {
	fake.teamPipelineJobsMutex.RLock()
	defer fake.teamPipelineJobsMutex.RUnlock()
	return len(fake.teamPipelineJobsArgsForCall)
}

func (fake *FakeAccessor) TeamPipelineJobsArgsForCall(i int) (accessor.Access, string, string) {
	fake.teamPipelineJobsMutex.RLock()
	defer fake.teamPipelineJobsMutex.RUnlock()
	return fake.teamPipelineJobsArgsForCall[i].arg1, fake.teamPipelineJobsArgsForCall[i].arg2, fake.teamPipelineJobsArgsForCall[i].arg3
}

func (fake *FakeAccessor) TeamPipelineJobsReturns(result1 []db.Job, result2 error) {
	fake.TeamPipelineJobsStub = nil
	fake.teamPipelineJobsReturns = struct {
		result1 []db.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineJobsReturnsOnCall(i int, result1 []db.Job, result2 error) {
	fake.TeamPipelineJobsStub = nil
	if fake.teamPipelineJobsReturnsOnCall == nil {
		fake.teamPipelineJobsReturnsOnCall = make(map[int]struct {
			result1 []db.Job
			result2 error
		})
	}
	fake.teamPipelineJobsReturnsOnCall[i] = struct {
		result1 []db.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineJob(arg1 accessor.Access, arg2 string, arg3 string, arg4 string) (db.Job, error) {
	fake.teamPipelineJobMutex.Lock()
	ret, specificReturn := fake.teamPipelineJobReturnsOnCall[len(fake.teamPipelineJobArgsForCall)]
	fake.teamPipelineJobArgsForCall = append(fake.teamPipelineJobArgsForCall, struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("TeamPipelineJob", []interface{}{arg1, arg2, arg3, arg4})
	fake.teamPipelineJobMutex.Unlock()
	if fake.TeamPipelineJobStub != nil {
		return fake.TeamPipelineJobStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamPipelineJobReturns.result1, fake.teamPipelineJobReturns.result2
}

func (fake *FakeAccessor) TeamPipelineJobCallCount() int {
	fake.teamPipelineJobMutex.RLock()
	defer fake.teamPipelineJobMutex.RUnlock()
	return len(fake.teamPipelineJobArgsForCall)
}

func (fake *FakeAccessor) TeamPipelineJobArgsForCall(i int) (accessor.Access, string, string, string) {
	fake.teamPipelineJobMutex.RLock()
	defer fake.teamPipelineJobMutex.RUnlock()
	return fake.teamPipelineJobArgsForCall[i].arg1, fake.teamPipelineJobArgsForCall[i].arg2, fake.teamPipelineJobArgsForCall[i].arg3, fake.teamPipelineJobArgsForCall[i].arg4
}

func (fake *FakeAccessor) TeamPipelineJobReturns(result1 db.Job, result2 error) {
	fake.TeamPipelineJobStub = nil
	fake.teamPipelineJobReturns = struct {
		result1 db.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineJobReturnsOnCall(i int, result1 db.Job, result2 error) {
	fake.TeamPipelineJobStub = nil
	if fake.teamPipelineJobReturnsOnCall == nil {
		fake.teamPipelineJobReturnsOnCall = make(map[int]struct {
			result1 db.Job
			result2 error
		})
	}
	fake.teamPipelineJobReturnsOnCall[i] = struct {
		result1 db.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineJobBuild(arg1 accessor.Access, arg2 string, arg3 string, arg4 string, arg5 string) (db.Build, error) {
	fake.teamPipelineJobBuildMutex.Lock()
	ret, specificReturn := fake.teamPipelineJobBuildReturnsOnCall[len(fake.teamPipelineJobBuildArgsForCall)]
	fake.teamPipelineJobBuildArgsForCall = append(fake.teamPipelineJobBuildArgsForCall, struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("TeamPipelineJobBuild", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.teamPipelineJobBuildMutex.Unlock()
	if fake.TeamPipelineJobBuildStub != nil {
		return fake.TeamPipelineJobBuildStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamPipelineJobBuildReturns.result1, fake.teamPipelineJobBuildReturns.result2
}

func (fake *FakeAccessor) TeamPipelineJobBuildCallCount() int {
	fake.teamPipelineJobBuildMutex.RLock()
	defer fake.teamPipelineJobBuildMutex.RUnlock()
	return len(fake.teamPipelineJobBuildArgsForCall)
}

func (fake *FakeAccessor) TeamPipelineJobBuildArgsForCall(i int) (accessor.Access, string, string, string, string) {
	fake.teamPipelineJobBuildMutex.RLock()
	defer fake.teamPipelineJobBuildMutex.RUnlock()
	return fake.teamPipelineJobBuildArgsForCall[i].arg1, fake.teamPipelineJobBuildArgsForCall[i].arg2, fake.teamPipelineJobBuildArgsForCall[i].arg3, fake.teamPipelineJobBuildArgsForCall[i].arg4, fake.teamPipelineJobBuildArgsForCall[i].arg5
}

func (fake *FakeAccessor) TeamPipelineJobBuildReturns(result1 db.Build, result2 error) {
	fake.TeamPipelineJobBuildStub = nil
	fake.teamPipelineJobBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineJobBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.TeamPipelineJobBuildStub = nil
	if fake.teamPipelineJobBuildReturnsOnCall == nil {
		fake.teamPipelineJobBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.teamPipelineJobBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) CreateTeampipelinJobBuilds(arg1 string, arg2 string, arg3 string, arg4 string) {
	fake.createTeampipelinJobBuildsMutex.Lock()
	fake.createTeampipelinJobBuildsArgsForCall = append(fake.createTeampipelinJobBuildsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("CreateTeampipelinJobBuilds", []interface{}{arg1, arg2, arg3, arg4})
	fake.createTeampipelinJobBuildsMutex.Unlock()
	if fake.CreateTeampipelinJobBuildsStub != nil {
		fake.CreateTeampipelinJobBuildsStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeAccessor) CreateTeampipelinJobBuildsCallCount() int {
	fake.createTeampipelinJobBuildsMutex.RLock()
	defer fake.createTeampipelinJobBuildsMutex.RUnlock()
	return len(fake.createTeampipelinJobBuildsArgsForCall)
}

func (fake *FakeAccessor) CreateTeampipelinJobBuildsArgsForCall(i int) (string, string, string, string) {
	fake.createTeampipelinJobBuildsMutex.RLock()
	defer fake.createTeampipelinJobBuildsMutex.RUnlock()
	return fake.createTeampipelinJobBuildsArgsForCall[i].arg1, fake.createTeampipelinJobBuildsArgsForCall[i].arg2, fake.createTeampipelinJobBuildsArgsForCall[i].arg3, fake.createTeampipelinJobBuildsArgsForCall[i].arg4
}

func (fake *FakeAccessor) TeamPipelineResources(arg1 accessor.Access, arg2 string, arg3 string) ([]db.Resource, error) {
	fake.teamPipelineResourcesMutex.Lock()
	ret, specificReturn := fake.teamPipelineResourcesReturnsOnCall[len(fake.teamPipelineResourcesArgsForCall)]
	fake.teamPipelineResourcesArgsForCall = append(fake.teamPipelineResourcesArgsForCall, struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("TeamPipelineResources", []interface{}{arg1, arg2, arg3})
	fake.teamPipelineResourcesMutex.Unlock()
	if fake.TeamPipelineResourcesStub != nil {
		return fake.TeamPipelineResourcesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamPipelineResourcesReturns.result1, fake.teamPipelineResourcesReturns.result2
}

func (fake *FakeAccessor) TeamPipelineResourcesCallCount() int {
	fake.teamPipelineResourcesMutex.RLock()
	defer fake.teamPipelineResourcesMutex.RUnlock()
	return len(fake.teamPipelineResourcesArgsForCall)
}

func (fake *FakeAccessor) TeamPipelineResourcesArgsForCall(i int) (accessor.Access, string, string) {
	fake.teamPipelineResourcesMutex.RLock()
	defer fake.teamPipelineResourcesMutex.RUnlock()
	return fake.teamPipelineResourcesArgsForCall[i].arg1, fake.teamPipelineResourcesArgsForCall[i].arg2, fake.teamPipelineResourcesArgsForCall[i].arg3
}

func (fake *FakeAccessor) TeamPipelineResourcesReturns(result1 []db.Resource, result2 error) {
	fake.TeamPipelineResourcesStub = nil
	fake.teamPipelineResourcesReturns = struct {
		result1 []db.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineResourcesReturnsOnCall(i int, result1 []db.Resource, result2 error) {
	fake.TeamPipelineResourcesStub = nil
	if fake.teamPipelineResourcesReturnsOnCall == nil {
		fake.teamPipelineResourcesReturnsOnCall = make(map[int]struct {
			result1 []db.Resource
			result2 error
		})
	}
	fake.teamPipelineResourcesReturnsOnCall[i] = struct {
		result1 []db.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineResource(arg1 accessor.Access, arg2 string, arg3 string, arg4 string) (db.Resource, error) {
	fake.teamPipelineResourceMutex.Lock()
	ret, specificReturn := fake.teamPipelineResourceReturnsOnCall[len(fake.teamPipelineResourceArgsForCall)]
	fake.teamPipelineResourceArgsForCall = append(fake.teamPipelineResourceArgsForCall, struct {
		arg1 accessor.Access
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("TeamPipelineResource", []interface{}{arg1, arg2, arg3, arg4})
	fake.teamPipelineResourceMutex.Unlock()
	if fake.TeamPipelineResourceStub != nil {
		return fake.TeamPipelineResourceStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamPipelineResourceReturns.result1, fake.teamPipelineResourceReturns.result2
}

func (fake *FakeAccessor) TeamPipelineResourceCallCount() int {
	fake.teamPipelineResourceMutex.RLock()
	defer fake.teamPipelineResourceMutex.RUnlock()
	return len(fake.teamPipelineResourceArgsForCall)
}

func (fake *FakeAccessor) TeamPipelineResourceArgsForCall(i int) (accessor.Access, string, string, string) {
	fake.teamPipelineResourceMutex.RLock()
	defer fake.teamPipelineResourceMutex.RUnlock()
	return fake.teamPipelineResourceArgsForCall[i].arg1, fake.teamPipelineResourceArgsForCall[i].arg2, fake.teamPipelineResourceArgsForCall[i].arg3, fake.teamPipelineResourceArgsForCall[i].arg4
}

func (fake *FakeAccessor) TeamPipelineResourceReturns(result1 db.Resource, result2 error) {
	fake.TeamPipelineResourceStub = nil
	fake.teamPipelineResourceReturns = struct {
		result1 db.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) TeamPipelineResourceReturnsOnCall(i int, result1 db.Resource, result2 error) {
	fake.TeamPipelineResourceStub = nil
	if fake.teamPipelineResourceReturnsOnCall == nil {
		fake.teamPipelineResourceReturnsOnCall = make(map[int]struct {
			result1 db.Resource
			result2 error
		})
	}
	fake.teamPipelineResourceReturnsOnCall[i] = struct {
		result1 db.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessor) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.adminMutex.RLock()
	defer fake.adminMutex.RUnlock()
	fake.pipelinesMutex.RLock()
	defer fake.pipelinesMutex.RUnlock()
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	fake.teamPipelinesMutex.RLock()
	defer fake.teamPipelinesMutex.RUnlock()
	fake.teamPipelineMutex.RLock()
	defer fake.teamPipelineMutex.RUnlock()
	fake.teamPipelineJobsMutex.RLock()
	defer fake.teamPipelineJobsMutex.RUnlock()
	fake.teamPipelineJobMutex.RLock()
	defer fake.teamPipelineJobMutex.RUnlock()
	fake.teamPipelineJobBuildMutex.RLock()
	defer fake.teamPipelineJobBuildMutex.RUnlock()
	fake.createTeampipelinJobBuildsMutex.RLock()
	defer fake.createTeampipelinJobBuildsMutex.RUnlock()
	fake.teamPipelineResourcesMutex.RLock()
	defer fake.teamPipelineResourcesMutex.RUnlock()
	fake.teamPipelineResourceMutex.RLock()
	defer fake.teamPipelineResourceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAccessor) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ accessor.Accessor = new(FakeAccessor)
