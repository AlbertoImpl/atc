// This file was generated by counterfeiter
package workerfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/lock"
	"github.com/concourse/atc/worker"
)

type FakeGardenWorkerDB struct {
	PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterStub        func(container db.Container, maxLifetime time.Duration) error
	putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex       sync.RWMutex
	putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterArgsForCall []struct {
		container   db.Container
		maxLifetime time.Duration
	}
	putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturns struct {
		result1 error
	}
	putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturnsOnCall map[int]struct {
		result1 error
	}
	GetContainerStub        func(handle string) (db.SavedContainer, bool, error)
	getContainerMutex       sync.RWMutex
	getContainerArgsForCall []struct {
		handle string
	}
	getContainerReturns struct {
		result1 db.SavedContainer
		result2 bool
		result3 error
	}
	getContainerReturnsOnCall map[int]struct {
		result1 db.SavedContainer
		result2 bool
		result3 error
	}
	GetPipelineByIDStub        func(pipelineID int) (db.SavedPipeline, error)
	getPipelineByIDMutex       sync.RWMutex
	getPipelineByIDArgsForCall []struct {
		pipelineID int
	}
	getPipelineByIDReturns struct {
		result1 db.SavedPipeline
		result2 error
	}
	getPipelineByIDReturnsOnCall map[int]struct {
		result1 db.SavedPipeline
		result2 error
	}
	AcquireVolumeCreatingLockStub        func(lager.Logger, int) (lock.Lock, bool, error)
	acquireVolumeCreatingLockMutex       sync.RWMutex
	acquireVolumeCreatingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
	}
	acquireVolumeCreatingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireVolumeCreatingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireContainerCreatingLockStub        func(lager.Logger, int) (lock.Lock, bool, error)
	acquireContainerCreatingLockMutex       sync.RWMutex
	acquireContainerCreatingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
	}
	acquireContainerCreatingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireContainerCreatingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGardenWorkerDB) PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLater(container db.Container, maxLifetime time.Duration) error {
	fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex.Lock()
	ret, specificReturn := fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturnsOnCall[len(fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterArgsForCall)]
	fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterArgsForCall = append(fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterArgsForCall, struct {
		container   db.Container
		maxLifetime time.Duration
	}{container, maxLifetime})
	fake.recordInvocation("PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLater", []interface{}{container, maxLifetime})
	fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex.Unlock()
	if fake.PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterStub != nil {
		return fake.PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterStub(container, maxLifetime)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturns.result1
}

func (fake *FakeGardenWorkerDB) PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterCallCount() int {
	fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex.RLock()
	defer fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex.RUnlock()
	return len(fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterArgsForCall)
}

func (fake *FakeGardenWorkerDB) PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterArgsForCall(i int) (db.Container, time.Duration) {
	fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex.RLock()
	defer fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex.RUnlock()
	return fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterArgsForCall[i].container, fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterArgsForCall[i].maxLifetime
}

func (fake *FakeGardenWorkerDB) PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturns(result1 error) {
	fake.PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterStub = nil
	fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGardenWorkerDB) PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturnsOnCall(i int, result1 error) {
	fake.PutTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterStub = nil
	if fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturnsOnCall == nil {
		fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGardenWorkerDB) GetContainer(handle string) (db.SavedContainer, bool, error) {
	fake.getContainerMutex.Lock()
	ret, specificReturn := fake.getContainerReturnsOnCall[len(fake.getContainerArgsForCall)]
	fake.getContainerArgsForCall = append(fake.getContainerArgsForCall, struct {
		handle string
	}{handle})
	fake.recordInvocation("GetContainer", []interface{}{handle})
	fake.getContainerMutex.Unlock()
	if fake.GetContainerStub != nil {
		return fake.GetContainerStub(handle)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getContainerReturns.result1, fake.getContainerReturns.result2, fake.getContainerReturns.result3
}

func (fake *FakeGardenWorkerDB) GetContainerCallCount() int {
	fake.getContainerMutex.RLock()
	defer fake.getContainerMutex.RUnlock()
	return len(fake.getContainerArgsForCall)
}

func (fake *FakeGardenWorkerDB) GetContainerArgsForCall(i int) string {
	fake.getContainerMutex.RLock()
	defer fake.getContainerMutex.RUnlock()
	return fake.getContainerArgsForCall[i].handle
}

func (fake *FakeGardenWorkerDB) GetContainerReturns(result1 db.SavedContainer, result2 bool, result3 error) {
	fake.GetContainerStub = nil
	fake.getContainerReturns = struct {
		result1 db.SavedContainer
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) GetContainerReturnsOnCall(i int, result1 db.SavedContainer, result2 bool, result3 error) {
	fake.GetContainerStub = nil
	if fake.getContainerReturnsOnCall == nil {
		fake.getContainerReturnsOnCall = make(map[int]struct {
			result1 db.SavedContainer
			result2 bool
			result3 error
		})
	}
	fake.getContainerReturnsOnCall[i] = struct {
		result1 db.SavedContainer
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) GetPipelineByID(pipelineID int) (db.SavedPipeline, error) {
	fake.getPipelineByIDMutex.Lock()
	ret, specificReturn := fake.getPipelineByIDReturnsOnCall[len(fake.getPipelineByIDArgsForCall)]
	fake.getPipelineByIDArgsForCall = append(fake.getPipelineByIDArgsForCall, struct {
		pipelineID int
	}{pipelineID})
	fake.recordInvocation("GetPipelineByID", []interface{}{pipelineID})
	fake.getPipelineByIDMutex.Unlock()
	if fake.GetPipelineByIDStub != nil {
		return fake.GetPipelineByIDStub(pipelineID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getPipelineByIDReturns.result1, fake.getPipelineByIDReturns.result2
}

func (fake *FakeGardenWorkerDB) GetPipelineByIDCallCount() int {
	fake.getPipelineByIDMutex.RLock()
	defer fake.getPipelineByIDMutex.RUnlock()
	return len(fake.getPipelineByIDArgsForCall)
}

func (fake *FakeGardenWorkerDB) GetPipelineByIDArgsForCall(i int) int {
	fake.getPipelineByIDMutex.RLock()
	defer fake.getPipelineByIDMutex.RUnlock()
	return fake.getPipelineByIDArgsForCall[i].pipelineID
}

func (fake *FakeGardenWorkerDB) GetPipelineByIDReturns(result1 db.SavedPipeline, result2 error) {
	fake.GetPipelineByIDStub = nil
	fake.getPipelineByIDReturns = struct {
		result1 db.SavedPipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeGardenWorkerDB) GetPipelineByIDReturnsOnCall(i int, result1 db.SavedPipeline, result2 error) {
	fake.GetPipelineByIDStub = nil
	if fake.getPipelineByIDReturnsOnCall == nil {
		fake.getPipelineByIDReturnsOnCall = make(map[int]struct {
			result1 db.SavedPipeline
			result2 error
		})
	}
	fake.getPipelineByIDReturnsOnCall[i] = struct {
		result1 db.SavedPipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLock(arg1 lager.Logger, arg2 int) (lock.Lock, bool, error) {
	fake.acquireVolumeCreatingLockMutex.Lock()
	ret, specificReturn := fake.acquireVolumeCreatingLockReturnsOnCall[len(fake.acquireVolumeCreatingLockArgsForCall)]
	fake.acquireVolumeCreatingLockArgsForCall = append(fake.acquireVolumeCreatingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AcquireVolumeCreatingLock", []interface{}{arg1, arg2})
	fake.acquireVolumeCreatingLockMutex.Unlock()
	if fake.AcquireVolumeCreatingLockStub != nil {
		return fake.AcquireVolumeCreatingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireVolumeCreatingLockReturns.result1, fake.acquireVolumeCreatingLockReturns.result2, fake.acquireVolumeCreatingLockReturns.result3
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLockCallCount() int {
	fake.acquireVolumeCreatingLockMutex.RLock()
	defer fake.acquireVolumeCreatingLockMutex.RUnlock()
	return len(fake.acquireVolumeCreatingLockArgsForCall)
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLockArgsForCall(i int) (lager.Logger, int) {
	fake.acquireVolumeCreatingLockMutex.RLock()
	defer fake.acquireVolumeCreatingLockMutex.RUnlock()
	return fake.acquireVolumeCreatingLockArgsForCall[i].arg1, fake.acquireVolumeCreatingLockArgsForCall[i].arg2
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireVolumeCreatingLockStub = nil
	fake.acquireVolumeCreatingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireVolumeCreatingLockStub = nil
	if fake.acquireVolumeCreatingLockReturnsOnCall == nil {
		fake.acquireVolumeCreatingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireVolumeCreatingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLock(arg1 lager.Logger, arg2 int) (lock.Lock, bool, error) {
	fake.acquireContainerCreatingLockMutex.Lock()
	ret, specificReturn := fake.acquireContainerCreatingLockReturnsOnCall[len(fake.acquireContainerCreatingLockArgsForCall)]
	fake.acquireContainerCreatingLockArgsForCall = append(fake.acquireContainerCreatingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AcquireContainerCreatingLock", []interface{}{arg1, arg2})
	fake.acquireContainerCreatingLockMutex.Unlock()
	if fake.AcquireContainerCreatingLockStub != nil {
		return fake.AcquireContainerCreatingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireContainerCreatingLockReturns.result1, fake.acquireContainerCreatingLockReturns.result2, fake.acquireContainerCreatingLockReturns.result3
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLockCallCount() int {
	fake.acquireContainerCreatingLockMutex.RLock()
	defer fake.acquireContainerCreatingLockMutex.RUnlock()
	return len(fake.acquireContainerCreatingLockArgsForCall)
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLockArgsForCall(i int) (lager.Logger, int) {
	fake.acquireContainerCreatingLockMutex.RLock()
	defer fake.acquireContainerCreatingLockMutex.RUnlock()
	return fake.acquireContainerCreatingLockArgsForCall[i].arg1, fake.acquireContainerCreatingLockArgsForCall[i].arg2
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireContainerCreatingLockStub = nil
	fake.acquireContainerCreatingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireContainerCreatingLockStub = nil
	if fake.acquireContainerCreatingLockReturnsOnCall == nil {
		fake.acquireContainerCreatingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireContainerCreatingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex.RLock()
	defer fake.putTheRestOfThisCrapInTheDatabaseButPleaseRemoveMeLaterMutex.RUnlock()
	fake.getContainerMutex.RLock()
	defer fake.getContainerMutex.RUnlock()
	fake.getPipelineByIDMutex.RLock()
	defer fake.getPipelineByIDMutex.RUnlock()
	fake.acquireVolumeCreatingLockMutex.RLock()
	defer fake.acquireVolumeCreatingLockMutex.RUnlock()
	fake.acquireContainerCreatingLockMutex.RLock()
	defer fake.acquireContainerCreatingLockMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeGardenWorkerDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.GardenWorkerDB = new(FakeGardenWorkerDB)
