// This file was generated by counterfeiter
package workerfakes

import (
	"io"
	"sync"

	"github.com/concourse/atc/dbng"
	"github.com/concourse/atc/worker"
	"github.com/concourse/baggageclaim"
)

type FakeVolume struct {
	HandleStub        func() string
	handleMutex       sync.RWMutex
	handleArgsForCall []struct{}
	handleReturns     struct {
		result1 string
	}
	PathStub        func() string
	pathMutex       sync.RWMutex
	pathArgsForCall []struct{}
	pathReturns     struct {
		result1 string
	}
	SetPropertyStub        func(key string, value string) error
	setPropertyMutex       sync.RWMutex
	setPropertyArgsForCall []struct {
		key   string
		value string
	}
	setPropertyReturns struct {
		result1 error
	}
	PropertiesStub        func() (baggageclaim.VolumeProperties, error)
	propertiesMutex       sync.RWMutex
	propertiesArgsForCall []struct{}
	propertiesReturns     struct {
		result1 baggageclaim.VolumeProperties
		result2 error
	}
	StreamInStub        func(path string, tarStream io.Reader) error
	streamInMutex       sync.RWMutex
	streamInArgsForCall []struct {
		path      string
		tarStream io.Reader
	}
	streamInReturns struct {
		result1 error
	}
	StreamOutStub        func(path string) (io.ReadCloser, error)
	streamOutMutex       sync.RWMutex
	streamOutArgsForCall []struct {
		path string
	}
	streamOutReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	COWStrategyStub        func() baggageclaim.COWStrategy
	cOWStrategyMutex       sync.RWMutex
	cOWStrategyArgsForCall []struct{}
	cOWStrategyReturns     struct {
		result1 baggageclaim.COWStrategy
	}
	IsInitializedStub        func() (bool, error)
	isInitializedMutex       sync.RWMutex
	isInitializedArgsForCall []struct{}
	isInitializedReturns     struct {
		result1 bool
		result2 error
	}
	InitializeStub        func() error
	initializeMutex       sync.RWMutex
	initializeArgsForCall []struct{}
	initializeReturns     struct {
		result1 error
	}
	CreateChildForContainerStub        func(dbng.CreatingContainer, string) (dbng.CreatingVolume, error)
	createChildForContainerMutex       sync.RWMutex
	createChildForContainerArgsForCall []struct {
		arg1 dbng.CreatingContainer
		arg2 string
	}
	createChildForContainerReturns struct {
		result1 dbng.CreatingVolume
		result2 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVolume) Handle() string {
	fake.handleMutex.Lock()
	fake.handleArgsForCall = append(fake.handleArgsForCall, struct{}{})
	fake.recordInvocation("Handle", []interface{}{})
	fake.handleMutex.Unlock()
	if fake.HandleStub != nil {
		return fake.HandleStub()
	}
	return fake.handleReturns.result1
}

func (fake *FakeVolume) HandleCallCount() int {
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	return len(fake.handleArgsForCall)
}

func (fake *FakeVolume) HandleReturns(result1 string) {
	fake.HandleStub = nil
	fake.handleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVolume) Path() string {
	fake.pathMutex.Lock()
	fake.pathArgsForCall = append(fake.pathArgsForCall, struct{}{})
	fake.recordInvocation("Path", []interface{}{})
	fake.pathMutex.Unlock()
	if fake.PathStub != nil {
		return fake.PathStub()
	}
	return fake.pathReturns.result1
}

func (fake *FakeVolume) PathCallCount() int {
	fake.pathMutex.RLock()
	defer fake.pathMutex.RUnlock()
	return len(fake.pathArgsForCall)
}

func (fake *FakeVolume) PathReturns(result1 string) {
	fake.PathStub = nil
	fake.pathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVolume) SetProperty(key string, value string) error {
	fake.setPropertyMutex.Lock()
	fake.setPropertyArgsForCall = append(fake.setPropertyArgsForCall, struct {
		key   string
		value string
	}{key, value})
	fake.recordInvocation("SetProperty", []interface{}{key, value})
	fake.setPropertyMutex.Unlock()
	if fake.SetPropertyStub != nil {
		return fake.SetPropertyStub(key, value)
	}
	return fake.setPropertyReturns.result1
}

func (fake *FakeVolume) SetPropertyCallCount() int {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	return len(fake.setPropertyArgsForCall)
}

func (fake *FakeVolume) SetPropertyArgsForCall(i int) (string, string) {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	return fake.setPropertyArgsForCall[i].key, fake.setPropertyArgsForCall[i].value
}

func (fake *FakeVolume) SetPropertyReturns(result1 error) {
	fake.SetPropertyStub = nil
	fake.setPropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVolume) Properties() (baggageclaim.VolumeProperties, error) {
	fake.propertiesMutex.Lock()
	fake.propertiesArgsForCall = append(fake.propertiesArgsForCall, struct{}{})
	fake.recordInvocation("Properties", []interface{}{})
	fake.propertiesMutex.Unlock()
	if fake.PropertiesStub != nil {
		return fake.PropertiesStub()
	}
	return fake.propertiesReturns.result1, fake.propertiesReturns.result2
}

func (fake *FakeVolume) PropertiesCallCount() int {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	return len(fake.propertiesArgsForCall)
}

func (fake *FakeVolume) PropertiesReturns(result1 baggageclaim.VolumeProperties, result2 error) {
	fake.PropertiesStub = nil
	fake.propertiesReturns = struct {
		result1 baggageclaim.VolumeProperties
		result2 error
	}{result1, result2}
}

func (fake *FakeVolume) StreamIn(path string, tarStream io.Reader) error {
	fake.streamInMutex.Lock()
	fake.streamInArgsForCall = append(fake.streamInArgsForCall, struct {
		path      string
		tarStream io.Reader
	}{path, tarStream})
	fake.recordInvocation("StreamIn", []interface{}{path, tarStream})
	fake.streamInMutex.Unlock()
	if fake.StreamInStub != nil {
		return fake.StreamInStub(path, tarStream)
	}
	return fake.streamInReturns.result1
}

func (fake *FakeVolume) StreamInCallCount() int {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return len(fake.streamInArgsForCall)
}

func (fake *FakeVolume) StreamInArgsForCall(i int) (string, io.Reader) {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return fake.streamInArgsForCall[i].path, fake.streamInArgsForCall[i].tarStream
}

func (fake *FakeVolume) StreamInReturns(result1 error) {
	fake.StreamInStub = nil
	fake.streamInReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVolume) StreamOut(path string) (io.ReadCloser, error) {
	fake.streamOutMutex.Lock()
	fake.streamOutArgsForCall = append(fake.streamOutArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("StreamOut", []interface{}{path})
	fake.streamOutMutex.Unlock()
	if fake.StreamOutStub != nil {
		return fake.StreamOutStub(path)
	}
	return fake.streamOutReturns.result1, fake.streamOutReturns.result2
}

func (fake *FakeVolume) StreamOutCallCount() int {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return len(fake.streamOutArgsForCall)
}

func (fake *FakeVolume) StreamOutArgsForCall(i int) string {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return fake.streamOutArgsForCall[i].path
}

func (fake *FakeVolume) StreamOutReturns(result1 io.ReadCloser, result2 error) {
	fake.StreamOutStub = nil
	fake.streamOutReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeVolume) COWStrategy() baggageclaim.COWStrategy {
	fake.cOWStrategyMutex.Lock()
	fake.cOWStrategyArgsForCall = append(fake.cOWStrategyArgsForCall, struct{}{})
	fake.recordInvocation("COWStrategy", []interface{}{})
	fake.cOWStrategyMutex.Unlock()
	if fake.COWStrategyStub != nil {
		return fake.COWStrategyStub()
	}
	return fake.cOWStrategyReturns.result1
}

func (fake *FakeVolume) COWStrategyCallCount() int {
	fake.cOWStrategyMutex.RLock()
	defer fake.cOWStrategyMutex.RUnlock()
	return len(fake.cOWStrategyArgsForCall)
}

func (fake *FakeVolume) COWStrategyReturns(result1 baggageclaim.COWStrategy) {
	fake.COWStrategyStub = nil
	fake.cOWStrategyReturns = struct {
		result1 baggageclaim.COWStrategy
	}{result1}
}

func (fake *FakeVolume) IsInitialized() (bool, error) {
	fake.isInitializedMutex.Lock()
	fake.isInitializedArgsForCall = append(fake.isInitializedArgsForCall, struct{}{})
	fake.recordInvocation("IsInitialized", []interface{}{})
	fake.isInitializedMutex.Unlock()
	if fake.IsInitializedStub != nil {
		return fake.IsInitializedStub()
	}
	return fake.isInitializedReturns.result1, fake.isInitializedReturns.result2
}

func (fake *FakeVolume) IsInitializedCallCount() int {
	fake.isInitializedMutex.RLock()
	defer fake.isInitializedMutex.RUnlock()
	return len(fake.isInitializedArgsForCall)
}

func (fake *FakeVolume) IsInitializedReturns(result1 bool, result2 error) {
	fake.IsInitializedStub = nil
	fake.isInitializedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeVolume) Initialize() error {
	fake.initializeMutex.Lock()
	fake.initializeArgsForCall = append(fake.initializeArgsForCall, struct{}{})
	fake.recordInvocation("Initialize", []interface{}{})
	fake.initializeMutex.Unlock()
	if fake.InitializeStub != nil {
		return fake.InitializeStub()
	}
	return fake.initializeReturns.result1
}

func (fake *FakeVolume) InitializeCallCount() int {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	return len(fake.initializeArgsForCall)
}

func (fake *FakeVolume) InitializeReturns(result1 error) {
	fake.InitializeStub = nil
	fake.initializeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVolume) CreateChildForContainer(arg1 dbng.CreatingContainer, arg2 string) (dbng.CreatingVolume, error) {
	fake.createChildForContainerMutex.Lock()
	fake.createChildForContainerArgsForCall = append(fake.createChildForContainerArgsForCall, struct {
		arg1 dbng.CreatingContainer
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateChildForContainer", []interface{}{arg1, arg2})
	fake.createChildForContainerMutex.Unlock()
	if fake.CreateChildForContainerStub != nil {
		return fake.CreateChildForContainerStub(arg1, arg2)
	}
	return fake.createChildForContainerReturns.result1, fake.createChildForContainerReturns.result2
}

func (fake *FakeVolume) CreateChildForContainerCallCount() int {
	fake.createChildForContainerMutex.RLock()
	defer fake.createChildForContainerMutex.RUnlock()
	return len(fake.createChildForContainerArgsForCall)
}

func (fake *FakeVolume) CreateChildForContainerArgsForCall(i int) (dbng.CreatingContainer, string) {
	fake.createChildForContainerMutex.RLock()
	defer fake.createChildForContainerMutex.RUnlock()
	return fake.createChildForContainerArgsForCall[i].arg1, fake.createChildForContainerArgsForCall[i].arg2
}

func (fake *FakeVolume) CreateChildForContainerReturns(result1 dbng.CreatingVolume, result2 error) {
	fake.CreateChildForContainerStub = nil
	fake.createChildForContainerReturns = struct {
		result1 dbng.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolume) Destroy() error {
	fake.destroyMutex.Lock()
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	return fake.destroyReturns.result1
}

func (fake *FakeVolume) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeVolume) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVolume) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	fake.pathMutex.RLock()
	defer fake.pathMutex.RUnlock()
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	fake.cOWStrategyMutex.RLock()
	defer fake.cOWStrategyMutex.RUnlock()
	fake.isInitializedMutex.RLock()
	defer fake.isInitializedMutex.RUnlock()
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	fake.createChildForContainerMutex.RLock()
	defer fake.createChildForContainerMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeVolume) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.Volume = new(FakeVolume)
