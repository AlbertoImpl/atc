// This file was generated by counterfeiter
package fakes

import (
	"sync"
	"time"

	"github.com/concourse/atc"
	"github.com/concourse/atc/worker"
)

type FakeImage struct {
	VolumeStub        func() worker.Volume
	volumeMutex       sync.RWMutex
	volumeArgsForCall []struct{}
	volumeReturns     struct {
		result1 worker.Volume
	}
	MetadataStub        func() worker.ImageMetadata
	metadataMutex       sync.RWMutex
	metadataArgsForCall []struct{}
	metadataReturns     struct {
		result1 worker.ImageMetadata
	}
	ReleaseStub        func(*time.Duration)
	releaseMutex       sync.RWMutex
	releaseArgsForCall []struct {
		arg1 *time.Duration
	}
	VersionStub        func() atc.Version
	versionMutex       sync.RWMutex
	versionArgsForCall []struct{}
	versionReturns     struct {
		result1 atc.Version
	}
}

func (fake *FakeImage) Volume() worker.Volume {
	fake.volumeMutex.Lock()
	fake.volumeArgsForCall = append(fake.volumeArgsForCall, struct{}{})
	fake.volumeMutex.Unlock()
	if fake.VolumeStub != nil {
		return fake.VolumeStub()
	} else {
		return fake.volumeReturns.result1
	}
}

func (fake *FakeImage) VolumeCallCount() int {
	fake.volumeMutex.RLock()
	defer fake.volumeMutex.RUnlock()
	return len(fake.volumeArgsForCall)
}

func (fake *FakeImage) VolumeReturns(result1 worker.Volume) {
	fake.VolumeStub = nil
	fake.volumeReturns = struct {
		result1 worker.Volume
	}{result1}
}

func (fake *FakeImage) Metadata() worker.ImageMetadata {
	fake.metadataMutex.Lock()
	fake.metadataArgsForCall = append(fake.metadataArgsForCall, struct{}{})
	fake.metadataMutex.Unlock()
	if fake.MetadataStub != nil {
		return fake.MetadataStub()
	} else {
		return fake.metadataReturns.result1
	}
}

func (fake *FakeImage) MetadataCallCount() int {
	fake.metadataMutex.RLock()
	defer fake.metadataMutex.RUnlock()
	return len(fake.metadataArgsForCall)
}

func (fake *FakeImage) MetadataReturns(result1 worker.ImageMetadata) {
	fake.MetadataStub = nil
	fake.metadataReturns = struct {
		result1 worker.ImageMetadata
	}{result1}
}

func (fake *FakeImage) Release(arg1 *time.Duration) {
	fake.releaseMutex.Lock()
	fake.releaseArgsForCall = append(fake.releaseArgsForCall, struct {
		arg1 *time.Duration
	}{arg1})
	fake.releaseMutex.Unlock()
	if fake.ReleaseStub != nil {
		fake.ReleaseStub(arg1)
	}
}

func (fake *FakeImage) ReleaseCallCount() int {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return len(fake.releaseArgsForCall)
}

func (fake *FakeImage) ReleaseArgsForCall(i int) *time.Duration {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return fake.releaseArgsForCall[i].arg1
}

func (fake *FakeImage) Version() atc.Version {
	fake.versionMutex.Lock()
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct{}{})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub()
	} else {
		return fake.versionReturns.result1
	}
}

func (fake *FakeImage) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeImage) VersionReturns(result1 atc.Version) {
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 atc.Version
	}{result1}
}

var _ worker.Image = new(FakeImage)
