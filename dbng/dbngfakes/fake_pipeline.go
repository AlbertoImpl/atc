// This file was generated by counterfeiter
package dbngfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db/lock"
	"github.com/concourse/atc/dbng"
)

type FakePipeline struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct{}
	teamIDReturns     struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	ConfigVersionStub        func() dbng.ConfigVersion
	configVersionMutex       sync.RWMutex
	configVersionArgsForCall []struct{}
	configVersionReturns     struct {
		result1 dbng.ConfigVersion
	}
	configVersionReturnsOnCall map[int]struct {
		result1 dbng.ConfigVersion
	}
	SaveJobStub        func(job atc.JobConfig) error
	saveJobMutex       sync.RWMutex
	saveJobArgsForCall []struct {
		job atc.JobConfig
	}
	saveJobReturns struct {
		result1 error
	}
	saveJobReturnsOnCall map[int]struct {
		result1 error
	}
	CreateJobBuildStub        func(jobName string) (dbng.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		jobName string
	}
	createJobBuildReturns struct {
		result1 dbng.Build
		result2 error
	}
	createJobBuildReturnsOnCall map[int]struct {
		result1 dbng.Build
		result2 error
	}
	CreateResourceStub        func(name string, config atc.ResourceConfig) (*dbng.Resource, error)
	createResourceMutex       sync.RWMutex
	createResourceArgsForCall []struct {
		name   string
		config atc.ResourceConfig
	}
	createResourceReturns struct {
		result1 *dbng.Resource
		result2 error
	}
	createResourceReturnsOnCall map[int]struct {
		result1 *dbng.Resource
		result2 error
	}
	AcquireResourceCheckingLockWithIntervalCheckStub        func(logger lager.Logger, resource *dbng.Resource, resourceTypes atc.VersionedResourceTypes, length time.Duration, immediate bool) (lock.Lock, bool, error)
	acquireResourceCheckingLockWithIntervalCheckMutex       sync.RWMutex
	acquireResourceCheckingLockWithIntervalCheckArgsForCall []struct {
		logger        lager.Logger
		resource      *dbng.Resource
		resourceTypes atc.VersionedResourceTypes
		length        time.Duration
		immediate     bool
	}
	acquireResourceCheckingLockWithIntervalCheckReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceCheckingLockWithIntervalCheckReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	ResourceTypesStub        func() ([]dbng.ResourceType, error)
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct{}
	resourceTypesReturns     struct {
		result1 []dbng.ResourceType
		result2 error
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 []dbng.ResourceType
		result2 error
	}
	ResourceTypeStub        func(name string) (dbng.ResourceType, bool, error)
	resourceTypeMutex       sync.RWMutex
	resourceTypeArgsForCall []struct {
		name string
	}
	resourceTypeReturns struct {
		result1 dbng.ResourceType
		result2 bool
		result3 error
	}
	resourceTypeReturnsOnCall map[int]struct {
		result1 dbng.ResourceType
		result2 bool
		result3 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipeline) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakePipeline) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakePipeline) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakePipeline) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakePipeline) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct{}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamIDReturns.result1
}

func (fake *FakePipeline) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakePipeline) TeamIDReturns(result1 int) {
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamIDReturnsOnCall(i int, result1 int) {
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) ConfigVersion() dbng.ConfigVersion {
	fake.configVersionMutex.Lock()
	ret, specificReturn := fake.configVersionReturnsOnCall[len(fake.configVersionArgsForCall)]
	fake.configVersionArgsForCall = append(fake.configVersionArgsForCall, struct{}{})
	fake.recordInvocation("ConfigVersion", []interface{}{})
	fake.configVersionMutex.Unlock()
	if fake.ConfigVersionStub != nil {
		return fake.ConfigVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configVersionReturns.result1
}

func (fake *FakePipeline) ConfigVersionCallCount() int {
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	return len(fake.configVersionArgsForCall)
}

func (fake *FakePipeline) ConfigVersionReturns(result1 dbng.ConfigVersion) {
	fake.ConfigVersionStub = nil
	fake.configVersionReturns = struct {
		result1 dbng.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) ConfigVersionReturnsOnCall(i int, result1 dbng.ConfigVersion) {
	fake.ConfigVersionStub = nil
	if fake.configVersionReturnsOnCall == nil {
		fake.configVersionReturnsOnCall = make(map[int]struct {
			result1 dbng.ConfigVersion
		})
	}
	fake.configVersionReturnsOnCall[i] = struct {
		result1 dbng.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) SaveJob(job atc.JobConfig) error {
	fake.saveJobMutex.Lock()
	ret, specificReturn := fake.saveJobReturnsOnCall[len(fake.saveJobArgsForCall)]
	fake.saveJobArgsForCall = append(fake.saveJobArgsForCall, struct {
		job atc.JobConfig
	}{job})
	fake.recordInvocation("SaveJob", []interface{}{job})
	fake.saveJobMutex.Unlock()
	if fake.SaveJobStub != nil {
		return fake.SaveJobStub(job)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveJobReturns.result1
}

func (fake *FakePipeline) SaveJobCallCount() int {
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	return len(fake.saveJobArgsForCall)
}

func (fake *FakePipeline) SaveJobArgsForCall(i int) atc.JobConfig {
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	return fake.saveJobArgsForCall[i].job
}

func (fake *FakePipeline) SaveJobReturns(result1 error) {
	fake.SaveJobStub = nil
	fake.saveJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveJobReturnsOnCall(i int, result1 error) {
	fake.SaveJobStub = nil
	if fake.saveJobReturnsOnCall == nil {
		fake.saveJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) CreateJobBuild(jobName string) (dbng.Build, error) {
	fake.createJobBuildMutex.Lock()
	ret, specificReturn := fake.createJobBuildReturnsOnCall[len(fake.createJobBuildArgsForCall)]
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("CreateJobBuild", []interface{}{jobName})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
}

func (fake *FakePipeline) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakePipeline) CreateJobBuildArgsForCall(i int) string {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].jobName
}

func (fake *FakePipeline) CreateJobBuildReturns(result1 dbng.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateJobBuildReturnsOnCall(i int, result1 dbng.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	if fake.createJobBuildReturnsOnCall == nil {
		fake.createJobBuildReturnsOnCall = make(map[int]struct {
			result1 dbng.Build
			result2 error
		})
	}
	fake.createJobBuildReturnsOnCall[i] = struct {
		result1 dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateResource(name string, config atc.ResourceConfig) (*dbng.Resource, error) {
	fake.createResourceMutex.Lock()
	ret, specificReturn := fake.createResourceReturnsOnCall[len(fake.createResourceArgsForCall)]
	fake.createResourceArgsForCall = append(fake.createResourceArgsForCall, struct {
		name   string
		config atc.ResourceConfig
	}{name, config})
	fake.recordInvocation("CreateResource", []interface{}{name, config})
	fake.createResourceMutex.Unlock()
	if fake.CreateResourceStub != nil {
		return fake.CreateResourceStub(name, config)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createResourceReturns.result1, fake.createResourceReturns.result2
}

func (fake *FakePipeline) CreateResourceCallCount() int {
	fake.createResourceMutex.RLock()
	defer fake.createResourceMutex.RUnlock()
	return len(fake.createResourceArgsForCall)
}

func (fake *FakePipeline) CreateResourceArgsForCall(i int) (string, atc.ResourceConfig) {
	fake.createResourceMutex.RLock()
	defer fake.createResourceMutex.RUnlock()
	return fake.createResourceArgsForCall[i].name, fake.createResourceArgsForCall[i].config
}

func (fake *FakePipeline) CreateResourceReturns(result1 *dbng.Resource, result2 error) {
	fake.CreateResourceStub = nil
	fake.createResourceReturns = struct {
		result1 *dbng.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateResourceReturnsOnCall(i int, result1 *dbng.Resource, result2 error) {
	fake.CreateResourceStub = nil
	if fake.createResourceReturnsOnCall == nil {
		fake.createResourceReturnsOnCall = make(map[int]struct {
			result1 *dbng.Resource
			result2 error
		})
	}
	fake.createResourceReturnsOnCall[i] = struct {
		result1 *dbng.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheck(logger lager.Logger, resource *dbng.Resource, resourceTypes atc.VersionedResourceTypes, length time.Duration, immediate bool) (lock.Lock, bool, error) {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.Lock()
	ret, specificReturn := fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall[len(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall)]
	fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall = append(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall, struct {
		logger        lager.Logger
		resource      *dbng.Resource
		resourceTypes atc.VersionedResourceTypes
		length        time.Duration
		immediate     bool
	}{logger, resource, resourceTypes, length, immediate})
	fake.recordInvocation("AcquireResourceCheckingLockWithIntervalCheck", []interface{}{logger, resource, resourceTypes, length, immediate})
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.Unlock()
	if fake.AcquireResourceCheckingLockWithIntervalCheckStub != nil {
		return fake.AcquireResourceCheckingLockWithIntervalCheckStub(logger, resource, resourceTypes, length, immediate)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireResourceCheckingLockWithIntervalCheckReturns.result1, fake.acquireResourceCheckingLockWithIntervalCheckReturns.result2, fake.acquireResourceCheckingLockWithIntervalCheckReturns.result3
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckCallCount() int {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	return len(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall)
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckArgsForCall(i int) (lager.Logger, *dbng.Resource, atc.VersionedResourceTypes, time.Duration, bool) {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	return fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].logger, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].resource, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].resourceTypes, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].length, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].immediate
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockWithIntervalCheckStub = nil
	fake.acquireResourceCheckingLockWithIntervalCheckReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockWithIntervalCheckStub = nil
	if fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall == nil {
		fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypes() ([]dbng.ResourceType, error) {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct{}{})
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if fake.ResourceTypesStub != nil {
		return fake.ResourceTypesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.resourceTypesReturns.result1, fake.resourceTypesReturns.result2
}

func (fake *FakePipeline) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakePipeline) ResourceTypesReturns(result1 []dbng.ResourceType, result2 error) {
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 []dbng.ResourceType
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceTypesReturnsOnCall(i int, result1 []dbng.ResourceType, result2 error) {
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 []dbng.ResourceType
			result2 error
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 []dbng.ResourceType
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceType(name string) (dbng.ResourceType, bool, error) {
	fake.resourceTypeMutex.Lock()
	ret, specificReturn := fake.resourceTypeReturnsOnCall[len(fake.resourceTypeArgsForCall)]
	fake.resourceTypeArgsForCall = append(fake.resourceTypeArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("ResourceType", []interface{}{name})
	fake.resourceTypeMutex.Unlock()
	if fake.ResourceTypeStub != nil {
		return fake.ResourceTypeStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.resourceTypeReturns.result1, fake.resourceTypeReturns.result2, fake.resourceTypeReturns.result3
}

func (fake *FakePipeline) ResourceTypeCallCount() int {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return len(fake.resourceTypeArgsForCall)
}

func (fake *FakePipeline) ResourceTypeArgsForCall(i int) string {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return fake.resourceTypeArgsForCall[i].name
}

func (fake *FakePipeline) ResourceTypeReturns(result1 dbng.ResourceType, result2 bool, result3 error) {
	fake.ResourceTypeStub = nil
	fake.resourceTypeReturns = struct {
		result1 dbng.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypeReturnsOnCall(i int, result1 dbng.ResourceType, result2 bool, result3 error) {
	fake.ResourceTypeStub = nil
	if fake.resourceTypeReturnsOnCall == nil {
		fake.resourceTypeReturnsOnCall = make(map[int]struct {
			result1 dbng.ResourceType
			result2 bool
			result3 error
		})
	}
	fake.resourceTypeReturnsOnCall[i] = struct {
		result1 dbng.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyReturns.result1
}

func (fake *FakePipeline) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakePipeline) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DestroyReturnsOnCall(i int, result1 error) {
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.createResourceMutex.RLock()
	defer fake.createResourceMutex.RUnlock()
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePipeline) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dbng.Pipeline = new(FakePipeline)
