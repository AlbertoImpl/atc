// This file was generated by counterfeiter
package fakes

import (
	"sync"
	"time"

	"github.com/concourse/atc/db"
	"github.com/concourse/atc/engine"
	"github.com/pivotal-golang/lager"
)

type FakeBuildDB struct {
	AbortBuildStub        func(int) error
	abortBuildMutex       sync.RWMutex
	abortBuildArgsForCall []struct {
		arg1 int
	}
	abortBuildReturns struct {
		result1 error
	}
	LeaseBuildTrackingStub        func(logger lager.Logger, buildID int, interval time.Duration) (db.Lease, bool, error)
	leaseBuildTrackingMutex       sync.RWMutex
	leaseBuildTrackingArgsForCall []struct {
		logger   lager.Logger
		buildID  int
		interval time.Duration
	}
	leaseBuildTrackingReturns struct {
		result1 db.Lease
		result2 bool
		result3 error
	}
}

func (fake *FakeBuildDB) AbortBuild(arg1 int) error {
	fake.abortBuildMutex.Lock()
	fake.abortBuildArgsForCall = append(fake.abortBuildArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.abortBuildMutex.Unlock()
	if fake.AbortBuildStub != nil {
		return fake.AbortBuildStub(arg1)
	} else {
		return fake.abortBuildReturns.result1
	}
}

func (fake *FakeBuildDB) AbortBuildCallCount() int {
	fake.abortBuildMutex.RLock()
	defer fake.abortBuildMutex.RUnlock()
	return len(fake.abortBuildArgsForCall)
}

func (fake *FakeBuildDB) AbortBuildArgsForCall(i int) int {
	fake.abortBuildMutex.RLock()
	defer fake.abortBuildMutex.RUnlock()
	return fake.abortBuildArgsForCall[i].arg1
}

func (fake *FakeBuildDB) AbortBuildReturns(result1 error) {
	fake.AbortBuildStub = nil
	fake.abortBuildReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildDB) LeaseBuildTracking(logger lager.Logger, buildID int, interval time.Duration) (db.Lease, bool, error) {
	fake.leaseBuildTrackingMutex.Lock()
	fake.leaseBuildTrackingArgsForCall = append(fake.leaseBuildTrackingArgsForCall, struct {
		logger   lager.Logger
		buildID  int
		interval time.Duration
	}{logger, buildID, interval})
	fake.leaseBuildTrackingMutex.Unlock()
	if fake.LeaseBuildTrackingStub != nil {
		return fake.LeaseBuildTrackingStub(logger, buildID, interval)
	} else {
		return fake.leaseBuildTrackingReturns.result1, fake.leaseBuildTrackingReturns.result2, fake.leaseBuildTrackingReturns.result3
	}
}

func (fake *FakeBuildDB) LeaseBuildTrackingCallCount() int {
	fake.leaseBuildTrackingMutex.RLock()
	defer fake.leaseBuildTrackingMutex.RUnlock()
	return len(fake.leaseBuildTrackingArgsForCall)
}

func (fake *FakeBuildDB) LeaseBuildTrackingArgsForCall(i int) (lager.Logger, int, time.Duration) {
	fake.leaseBuildTrackingMutex.RLock()
	defer fake.leaseBuildTrackingMutex.RUnlock()
	return fake.leaseBuildTrackingArgsForCall[i].logger, fake.leaseBuildTrackingArgsForCall[i].buildID, fake.leaseBuildTrackingArgsForCall[i].interval
}

func (fake *FakeBuildDB) LeaseBuildTrackingReturns(result1 db.Lease, result2 bool, result3 error) {
	fake.LeaseBuildTrackingStub = nil
	fake.leaseBuildTrackingReturns = struct {
		result1 db.Lease
		result2 bool
		result3 error
	}{result1, result2, result3}
}

var _ engine.BuildDB = new(FakeBuildDB)
